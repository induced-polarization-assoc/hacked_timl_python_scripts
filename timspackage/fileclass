#!/bin/env python
#  Copyright (c) 2019. Induced Polarization Associates, LLC, Seattle, WA
__author__ = ['Joseph J. Radler', 'Tim Lewis']
import numpy as np
import scipy as sp
from scipy import fftpack as spfftpack
from datetime import datetime
from pathlib import Path as Path
import timspackage.commonSense as cs
from timspackage.commonSense import emptyClass


class FileClass:
    """
    .. class:: fileclass

    .. summary::
    Object that represents a parsed `data.txt` file with all the appropriate attributes populated
    by the parsed data.

    .. parameters::
        path
        to_save
        fileName

    .. attributes::
        self.count_lines(fh)
        self.raw[:, p, s]
        self.n
        self.pkt[p]
        self.cpuDTStr[p].d,
        self.cpuDTStr[p].t
        self.cpuDT[p]
        self.lat[p],
        self.longi[p]
        self.clipLo[:, p]
        self.clipHi[:, p]
        self.meanUpPct[:, p]
        self.meanDnPct[:, p]
        self.countDn[:, p]
        self.fileDateStr
        self.fileNum
        self.descript # Description of the test.
        self.minor # Minor note.
        self.major   # Major note.
        self.scanChCount,  # number of channels in each A/D scan.
        self.chCount,  # number of channels written to the file.
        self.n,  # Number of samples in the FFT time series.
        self.fs,  # (Hz) FFT sampling frequency.
        self.xmitFund  # (Hz) Transmit Square
        self.pktCount = int((line_count - 10)/(11 + self.n))
        self.init_array_dims()
        self.rCurrentMeas,  # (Ohm) resistance.
        self.rExtraSeries
        self.measStr
        self.In5BHi = sp.fromstring(line, dtype=float, sep=',')
        self.Out5BHi = sp.fromstring(line, dtype=float, sep=',')
        self.ALoadQHi = sp.fromstring(line, dtype=float, sep=',')

    .. methods::
        introduce(self, fileName)
        read_txt(self, path, to_save)
        init_array_dims(self)
        string_to_datetime(self, DTStr)
        compute_phys(self, channel)
        pct_to_phys(self, pct, channel)
        count_lines(self, fh)
        post_read(self, saveThis)
    """
    def __init__(self, name, path, to_save, auto_postprocess=True):
        """
        .. method:: __init__()
        File object constructor method that initializes all values with default values or placeholders
        in anticipation of loading the values from file with FileClass methods.
        :param name:
        :param path:
        :param to_save:
        :param auto_postprocess:
            Defaults to true.

        """
        # File location attributes
        self.corrChSkewBool = True
        self.file_name = name
        self.file_path = path
        self.save_this = to_save

        # File Header Metadata Defaults
        self.fileDateStr = ''
        self.fileNum = 0
        self.descript = 'description'  # Description of the test.
        self.minor = 'minor note'  # Minor note.
        self.major = 'major note'  # Major note.
        self.scanChCount = 8  # number of channels in each A/D scan.
        self.chCount = 8  # number of channels written to the file.
        self.n = 1  # Number of samples in the FFT time series.
        self.fs = 0.0  # (Hz) FFT sampling frequency.
        self.xmitFund = 0.0  # (Hz) Transmit Square
        self.pktCount = 1
        self.rCurrentMeas = 0  # (Ohm) resistance.
        self.rExtraSeries = 0  # Ohm
        self.measStr = 'measure string'
        self.raw = np.array([[], [], []])
        self.n = 1
        self.In5BHi = None
        self.Out5BHi = None
        self.ALoadQHi = None

        # Initialize the arrays as zero-filled arrays
        self.shape2D = (self.chCount, self.pktCount)
        # 0-indexed by packet number.
        self.pkt = sp.zeros(self.pktCount, dtype=int)
        # self.cpuDTStr = [cs.emptyClass()] * self.pktCount
        self.cpuDTStr = [emptyClass()] * self.pktCount
        self.cpuDT = [0] * self.pktCount
        # self.gpsDTStr = [cs.emptyClass()] * self.pktCount
        self.gpsDTStr = [emptyClass()] * self.pktCount
        self.gpsDT = [0] * self.pktCount
        self.lat = sp.zeros(self.pktCount, dtype=float)
        self.longi = sp.zeros(self.pktCount, dtype=float)
        # 0-indexed by channel number.
        # 0-indexed by packet number.
        self.clipHi = sp.zeros(self.shape2D, dtype=int)
        self.clipLo = sp.zeros(self.shape2D, dtype=int)
        self.meanPct = sp.zeros(self.shape2D, dtype=float)
        self.meanUpPct = sp.zeros(self.shape2D, dtype=float)
        self.meanDnPct = sp.zeros(self.shape2D, dtype=float)
        self.meanPhys = sp.zeros(self.shape2D, dtype=float)
        self.meanUpPhys = sp.zeros(self.shape2D, dtype=float)
        self.meanDnPhys = sp.zeros(self.shape2D, dtype=float)
        self.countUp = sp.zeros(self.shape2D, dtype=int)
        self.countDn = sp.zeros(self.shape2D, dtype=int)
        # 0-indexed by channel number.
        # 0-indexed by packet number.
        # 0-indexed by sample number.
        self.raw = sp.zeros((self.chCount, self.pktCount, self.n), dtype=float)

        # Initialize processing attributes associated with the file.
        self.freq = None
        self.fft = None
        self.phaseUnCorr = None
        self.mag16Bit = None
        self.magPhys = None
        self.phase = None
        self.phaseDiff = None
        self.zMag = None

        # Initialize this random little emptyClass thing
        emptyClass.d = None
        emptyClass.t = None

        # Automatically run the read_txt to populate the arrays
        self.read_txt()

        if auto_postprocess is True:
            # After the file has been read, perform some calculations.
            self.post_read()

    def introduce(self):
        """
        .. method:: introduce
        :return:
        """
        print('Creating %s from %s at %s.' % (self, self.file_name, self.file_path))

    def read_txt(self):
        """
        .. method read_txt()
            Takes in the file path as defined by the user that contains the raw text to be parsed and loaded
            into the file object.
        """
        # Read IP measurements from file_obj_array text file.
        with open(self.file_path, 'r') as fh:
            # Number of lines in the file.
            line_count = self.count_lines(fh)
            # Rewind the pointer in the file back to the beginning.
            fh.seek(0)
            # Initialize the packet counter.
            p = -1
            # Initialize the sample index.
            s = -1
            for lidx, line in enumerate(fh, 1):
                # Strip off trailing newline characters.
                line = line.rstrip('\n')
                if s >= 0:
                    # Read in raw voltage values.
                    self.raw[:, p, s] = (
                            sp.fromstring(line, dtype=float, sep=','))
                    if s == self.n - 1:
                        # Reset the counter to below zero.
                        s = -1
                    else:
                        # Increment the sample counter for the next read.
                        s += 1
                elif lidx > 10:
                    if line[0] == '$':
                        # Increment the packet index.
                        p += 1
                        # Reset the time domain quality parameter index.
                        qp = 0
                        # Packet number
                        self.pkt[p] = int(line[1:])
                    elif line[0] == '\'':
                        # CPU UTC Date and Time Strings.
                        (self.cpuDTStr[p].d,
                         self.cpuDTStr[p].t) = line[1:].split(',')
                        # Translate to datetime object.
                        self.cpuDT[p] = self.string_to_datetime(self.cpuDTStr[p])
                    elif line[0] == '@':
                        # GPS UTC Date and Time Strings,
                        # and latitude and longitude fixes.
                        (self.gpsDTStr[p].d,
                         self.gpsDTStr[p].t,
                         self.lat[p],
                         self.longi[p]) = line[1:].split(',')
                        # Translate to datetime object.
                        self.gpsDT[p] = self.string_to_datetime(self.gpsDTStr[p])
                        # Type casting.
                        self.lat[p] = float(self.lat[p])
                        self.longi[p] = float(self.longi[p])
                    elif qp < 7:
                        qp += 1
                        if qp == 3 or qp == 4 or qp == 5:
                            typ = float  # Means are saved as floats.
                        else:
                            typ = int  # Counts are saved as integers.
                        assign_array = sp.fromstring(line, dtype=typ, sep=',')
                        if qp == 1:
                            # Count of measurements clipped on the high end of
                            # the MccDaq board's input range.
                            self.clipHi[:, p] = assign_array
                        elif qp == 2:
                            # Count of measurements clipped on the low end of
                            # the MccDaq board's input range.
                            self.clipLo[:, p] = assign_array
                        elif qp == 3:
                            # Mean measurement value over the packet as file_obj_array
                            # percentage of the AIn() half range.
                            self.meanPct[:, p] = assign_array
                        elif qp == 4:
                            # (pct) Mean value of sample measurements above
                            # or equal to the mean.
                            self.meanUpPct[:, p] = assign_array
                        elif qp == 5:
                            # (pct) Mean value of sample measurements below
                            # the mean.
                            self.meanDnPct[:, p] = assign_array
                        elif qp == 6:
                            # Count of measurements above or equal to the mean.
                            self.countUp[:, p] = assign_array
                        elif qp == 7:
                            # Count of measurements below the mean.
                            self.countDn[:, p] = assign_array
                            # Set the sample index to 0 to start.
                            s = 0
                elif lidx == 1:
                    (self.fileDateStr,  # UTC date file was created.
                     self.fileNum) = line.split(',')  # File number in set.
                    # Type casting.
                    self.fileNum = int(self.fileNum)
                elif lidx == 2:
                    self.descript = line  # Description of the test.
                elif lidx == 3:
                    self.minor = line  # Minor note.
                elif lidx == 4:
                    self.major = line  # Major note.
                elif lidx == 5:
                    (self.scanChCount,  # number of channels in each A/D scan.
                     self.chCount,  # number of channels written to the file.
                     self.n,  # Number of samples in the FFT time series.
                     self.fs,  # (Hz) FFT sampling frequency.
                     self.xmitFund) = line.split(',')  # (Hz) Transmit Square
                    # wave fundamental frequency.
                    # Type casting.
                    self.scanChCount = int(self.scanChCount)
                    self.chCount = int(self.chCount)
                    self.n = int(self.n)
                    self.fs = int(self.fs)
                    self.xmitFund = float(self.xmitFund)
                    # Each file contains file_obj_array file header of length 10 lines,
                    # followed by packets. Packets contain (11 + n) lines each.
                    self.pktCount = int((line_count - 10)/(11 + self.n))
                    # Dimension arrays indexed by packet.
                    self.init_array_dims()
                elif lidx == 6:
                    (self.rCurrentMeas,  # (Ohm) resistance.
                     self.rExtraSeries) = line.split(',')  # (Ohm).
                    # Type casting.
                    self.rCurrentMeas = float(self.rCurrentMeas)
                    self.rExtraSeries = float(self.rCurrentMeas)
                elif lidx == 7:
                    # Voltage measurement names.
                    # 0-indexed by channel number.
                    self.measStr = line.split(',')
                elif lidx == 8:
                    # Construct arrays using the scipy package.
                    # 5B amplifier maximum of the input range (V).
                    # 0-indexed by channel number.
                    self.In5BHi = sp.fromstring(line, dtype=float, sep=',')
                elif lidx == 9:
                    # 5B amplifier maximum of the output range (V).
                    # 0-indexed by channel number.
                    self.Out5BHi = sp.fromstring(line, dtype=float, sep=',')
                elif lidx == 10:
                    # MccDaq board AIn() maximum of the input range (V).
                    # 0-indexed by channel number.
                    self.ALoadQHi = sp.fromstring(line, dtype=float, sep=',')
        # # After the file has been read, perform some calculations.
        # self.post_read()

    def init_array_dims(self):
        """
        Initialize numpy arrays and python lists as zeros
        :return:
        """
        shape2_d = self.shape2D
        # self.shape2_d = (self.chCount, self.pktCount)
        # 0-indexed by packet number.
        self.pkt = sp.zeros(self.pktCount, dtype=int)
        self.cpuDTStr = [cs.emptyClass()]*self.pktCount
        self.cpuDT = [0]*self.pktCount
        self.gpsDTStr = [cs.emptyClass()]*self.pktCount
        self.gpsDT = [0]*self.pktCount
        self.lat = sp.zeros(self.pktCount, dtype=float)
        self.longi = sp.zeros(self.pktCount, dtype=float)
        # 0-indexed by channel number.
        # 0-indexed by packet number.
        self.clipHi = sp.zeros(shape2_d, dtype=int)
        self.clipLo = sp.zeros(shape2_d, dtype=int)
        self.meanPct = sp.zeros(shape2_d, dtype=float)
        self.meanUpPct = sp.zeros(shape2_d, dtype=float)
        self.meanDnPct = sp.zeros(shape2_d, dtype=float)
        self.meanPhys = sp.zeros(shape2_d, dtype=float)
        self.meanUpPhys = sp.zeros(shape2_d, dtype=float)
        self.meanDnPhys = sp.zeros(shape2_d, dtype=float)
        self.countUp = sp.zeros(shape2_d, dtype=int)
        self.countDn = sp.zeros(shape2_d, dtype=int)
        # 0-indexed by channel number.
        # 0-indexed by packet number.
        # 0-indexed by sample number.
        self.raw = sp.zeros((self.chCount, self.pktCount, self.n), dtype=float)

    @staticmethod
    def string_to_datetime(date_time_string):
        """
        .. function:: string_to_datetime
        Converts a string to a date-time format to load into the fileclass object datetime attributes.
        :param date_time_string:
        :return:
        """
        YY = 2000 + int(date_time_string.d[0: 0 + 2])
        MO = int(date_time_string.d[2: 2 + 2])
        DD = int(date_time_string.d[4: 4 + 2])
        HH = int(date_time_string.t[0: 0 + 2])
        MM = int(date_time_string.t[2: 2 + 2])
        SS = int(date_time_string.t[4: 4 + 2])
        micro = 1000 * int(date_time_string.t[7: 7 + 3])
        if YY == 2000:
            return datetime.min
        else:
            return datetime(YY, MO, DD, HH, MM, SS, micro)

    def compute_phys(self, channel):
        """
        .. function:: compute_phys
        Computes the physical values from relative voltage percentages read by the ADC
        :param channel:
        :return:
        """
        self.meanPhys = self.pct_to_phys(self.meanPct, channel)
        self.meanUpPhys = self.pct_to_phys(self.meanUpPct, channel)
        self.meanDnPhys = self.pct_to_phys(self.meanDnPct, channel)

    def pct_to_phys(self, pct, channel):
        """
        .. function:: pct_to_phys
            Converts percentage values to physically meaningful voltage values.
        :param pct:
        :param channel:
        :return:
        """
        phys = sp.zeros_like(pct, dtype=float)
        for ch in range(self.chCount):
            phys[ch, :] = (pct[ch, :] / 100 *
                           self.ALoadQHi[ch] * self.In5BHi[ch] /
                           self.Out5BHi[ch])  # (V)
        # Convert the voltage on the current measurement channel to file_obj_array current.
        phys[channel, :] /= self.rCurrentMeas  # (A)
        return phys

    @staticmethod
    def count_lines(fh):
        """
        .. function count_lines
        Counter lidx starts counting at 1 for the first line.
        :param fh:
        :return lidx:
        """
        for lidx, line in enumerate(fh, 1):
            pass
        return lidx

    def post_read(self):
        """
        Whether to correct for channel skew.

        Channel on which the current is measured. This channel's phase is
        subtracted from the other channels in phase difference calculation.
        This channel's voltage is divided by the current measurement
        resistance to obtain file_obj_array physical magnitude in Ampere units.
        Other channels voltages are divided by this channel's current to find
        impedance magnitude.
        :return:
        """
        # FIXME:  THESE LINES BELOW SHOULD BE CONVERTED INTO DISCRETE METHODS OR FUNCTIONS OF ANOTHER CLASS
        # WHERE THESE MATHEMATICAL UTILITIES CAN BE RUN IN ISOLATION INSTEAD OF AS PART OF A SCRIPT.
        # THIS WILL ALSO MAKE THINGS EASIER TO COMPREHEND AND HACK ON AS WE'RE MODIFYING THE STUFF TO
        # INTERFACE WITH TODD'S RDBMS
        current_ch = 0

        # Flip voltage channels upside-down if requested.
        if self.save_this == 'upsideDown':
            for ch in range(self.chCount):
                if ch != current_ch:
                    self.raw[ch, ...] *= -1
                    self.raw[ch, ...] += 2**16 - 1

        self.compute_phys(current_ch)
        # Compute FFTs.
        self.freq = spfftpack.fftfreq(self.n, 1 / self.fs, )  # (Hz)
        self.fft = spfftpack.fft(self.raw) / self.n
        # Magnitude and uncorrected phase.
        self.phaseUnCorr = sp.angle(self.fft)  # (rad)
        self.mag16Bit = sp.absolute(self.fft)

        # Convert magnitude to physical units.
        f215 = float(2**15)
        self.magPhys = self.mag16Bit / f215
        for ch in range(self.chCount):
            self.magPhys[ch, :, :] *= (self.ALoadQHi[ch] * self.In5BHi[ch] /
                                       self.Out5BHi[ch])  # (V)
        # Convert the voltage on ch0 to file_obj_array current.
        self.magPhys[0, :, :] /= self.rCurrentMeas  # (A)

        # Correct phase for channel skew.
        self.phase = self.phaseUnCorr
        if self.corrChSkewBool:
            for ch in range(self.chCount):
                delta_t = ch / (self.fs * self.scanChCount)  # (s)
                corr_slope = 2*sp.pi*delta_t  # (rad/Hz)
                for p in range(self.pktCount):
                    self.phase[ch, p, :] = sp.subtract(self.phase[ch, p, :],
                                                       self.freq * corr_slope)

        # Compute phase differences.
        # Be careful about angles looping through +/- pi.
        # A phase difference absolute value is less than pi radian.
        self.phaseDiff = sp.zeros_like(self.phase, dtype=float)
        for ch in range(self.chCount):
            self.phaseDiff[ch, :, :] = sp.subtract(self.phase[ch, :, :],
                                                   self.phase[current_ch, :, :])
        self.phaseDiff[self.phaseDiff < -sp.pi] += 2*sp.pi
        self.phaseDiff[self.phaseDiff > sp.pi] -= 2*sp.pi

        # Convert phase differences from radian to milliradian.
        self.phaseDiff *= 1000  # (mrad)

        # Calculate apparent impedance magnitude.
        self.zMag = sp.zeros_like(self.magPhys)
        for ch in range(self.chCount):
            # (Ohm)
            self.zMag[ch, :, :] = sp.divide(self.magPhys[ch, :, :],
                                            self.magPhys[current_ch, :, :])
        # Convert to milliOhm.
        self.zMag *= 1000


if __name__ == "__main__":
    file_name = 'testfile1.txt'
    file_path = Path.home()
    save_this = 'raw'
    somefile = FileClass(file_name, file_path, save_this)